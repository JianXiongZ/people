From b3132c6246d6ca7a01fd3882b71ad8a0a1f7c4e8 Mon Sep 17 00:00:00 2001
From: Mikeqin <Fengling.Qin@gmail.com>
Date: Thu, 21 May 2015 12:53:45 +0800
Subject: [PATCH 1/2] Encrypt the packet

---
 firmware/main.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/firmware/main.c b/firmware/main.c
index a37629a..ad207d2 100644
--- a/firmware/main.c
+++ b/firmware/main.c
@@ -173,6 +173,8 @@ static void encode_pkg(uint8_t *p, int type, uint8_t *buf, unsigned int len)
 		memcpy(data + AVA4_MM_DNA_LEN, buf, len); /* MM_VERSION */
 		break;
 	case AVA4_P_NONCE:
+		p[3] = (g_dna[0] ^ g_dna[AVA4_MM_DNA_LEN - 1]);
+		memcpy(data, buf, len);
 	case AVA4_P_TEST_RET:
 		memcpy(data, buf, len);
 		break;
@@ -477,7 +479,10 @@ static inline int decode_pkg(uint8_t *p, struct mm_work *mw)
 		break;
 
 	case AVA4_P_POLLING:
-		polling();
+		if (opt == (g_dna[0] ^ g_dna[AVA4_MM_DNA_LEN - 1]))
+			polling();
+		else
+			send_pkg(AVA4_P_STATUS, NULL, 0, 0);
 
 		memcpy(&tmp, data, 4);
 		g_led_blinking = tmp;
-- 
2.0.0


From eaa45019d4f6bfde7968d3c6ee6a5b05045c868c Mon Sep 17 00:00:00 2001
From: Mikeqin <Fengling.Qin@gmail.com>
Date: Tue, 26 May 2015 11:26:13 +0800
Subject: [PATCH 2/2] Encrypt detect package

---
 firmware/main.c | 36 +++++++++++++++++++++++++++++++++---
 1 file changed, 33 insertions(+), 3 deletions(-)

diff --git a/firmware/main.c b/firmware/main.c
index ad207d2..b900d97 100644
--- a/firmware/main.c
+++ b/firmware/main.c
@@ -48,6 +48,7 @@ static uint32_t glastcpm[3];
 static struct mm_config g_mmcfg;
 static uint8_t g_runmode = MOD_ECO; /* high 4bits-save/setting, low 4bits-run mode */
 static uint8_t g_getvolopt;
+static uint8_t g_work_process = 0;
 
 #define RET_RINGBUFFER_SIZE_RX 32
 #define RET_RINGBUFFER_MASK_RX (RET_RINGBUFFER_SIZE_RX-1)
@@ -168,7 +169,7 @@ static void encode_pkg(uint8_t *p, int type, uint8_t *buf, unsigned int len)
 	data = p + 6;
 	switch (type) {
 	case AVA4_P_ACKDETECT:
-		p[3] = 0;
+		p[3] = g_module_id & 0xff;
 		memcpy(data, g_dna, AVA4_MM_DNA_LEN); /* MM_DNA */
 		memcpy(data + AVA4_MM_DNA_LEN, buf, len); /* MM_VERSION */
 		break;
@@ -412,6 +413,9 @@ static inline int decode_pkg(uint8_t *p, struct mm_work *mw)
 		debug32("[%d] N2: %08x(%08x-%08x)\n", g_module_id, mw->nonce2, g_nonce2_offset, g_nonce2_range);
 		break;
 	case AVA4_P_SET_VOLT:
+		if (!g_work_process)
+			break;
+
 		switch (opt & 0xf) {
 			case MOD_CUSTOM:
 			case MOD_ECO:
@@ -456,6 +460,9 @@ static inline int decode_pkg(uint8_t *p, struct mm_work *mw)
 		send_pkg(AVA4_P_STATUS_VOLT, NULL, 0, 0);
 		break;
 	case AVA4_P_SET_FREQ:
+		if (!g_work_process)
+			break;
+
 		memcpy(&val[2], data, 4);
 		memcpy(&val[1], data + 4, 4);
 		memcpy(&val[0], data + 8, 4);
@@ -647,12 +654,17 @@ static int get_pkg(struct mm_work *mw)
 				if (g_module_id != AVA4_MODULE_BROADCAST)
 					break;
 
+				/* FIXME: g_module_id is used in AVA4_P_ACKDETECT */
+				memcpy(&g_module_id, g_pkg + 6 + 28, 4);
 				if (send_pkg(AVA4_P_ACKDETECT, (uint8_t *)MM_VERSION, AVA4_MM_VER_LEN, 1)) {
-					memcpy(&g_module_id, g_pkg + 6 + 28, 4);
 					debug32("ID: %d\n", g_module_id);
 					iic_addr_set(g_module_id);
 					gpio_led(g_module_id);
-				}
+				} else
+					g_module_id = AVA4_MODULE_BROADCAST;
+
+				if ((g_module_id & 0xff) == g_pkg[3])
+					g_work_process = 1;
 				break;
 			case AVA4_P_REQUIRE:
 				send_pkg(AVA4_P_STATUS, NULL, 0, 0);
@@ -798,6 +810,7 @@ int main(int argv, char **argc)
 			g_local_work = 0;
 			g_hw_work = 0;
 			g_ntime_offset = ASIC_COUNT;
+			g_work_process = 0;
 
 			set_voltage(ASIC_0V);
 			for (i = 0; i < MINER_COUNT; i++) {
@@ -832,6 +845,23 @@ int main(int argv, char **argc)
 			continue;
 
 		pgcheck();
+
+		if (!g_work_process) {
+			g_local_work = 0;
+			g_hw_work = 0;
+			g_ntime_offset = ASIC_COUNT;
+
+			set_voltage(ASIC_0V);
+			for (i = 0; i < MINER_COUNT; i++) {
+				val[i] = ASIC_0V;
+				g_hw_work_i[i] = 0;
+			}
+			set_voltage_i(val);
+			glastcpm[0] = glastcpm[1] = glastcpm[2] = 0;
+			adjust_fan(FAN_10);
+			continue;
+		}
+
 		if (api_get_tx_cnt() <= 23 * MINER_COUNT) {
 			miner_gen_nonce2_work(&mm_work, mm_work.nonce2++, &work);
 			api_send_work(&work);
-- 
2.0.0

